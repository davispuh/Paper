From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 14 Jan 2022 16:45:56 -0800
Subject: [PATCH] fixup! Optimize anyPlayerCloseEnoughForSpawning to use
 distance maps


diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 1b6a4fdefa0a18cb400631ac4cb3c5294cf59a05..c6006a0330c6e6bcecf75c13d910a75ba12cb680 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -90,7 +90,7 @@ public class ChunkHolder {
     com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInMobSpawnRange;
     com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInChunkTickRange;
 
-    void updateRanges() {
+    void onChunkAdd() {
         long key = net.minecraft.server.MCUtil.getCoordinateKey(this.pos);
         this.playersInMobSpawnRange = this.chunkMap.playerMobSpawnMap.getObjectsInRange(key);
         this.playersInChunkTickRange = this.chunkMap.playerChunkTickRangeMap.getObjectsInRange(key);
@@ -101,6 +101,11 @@ public class ChunkHolder {
         }
         // Paper end - optimise checkDespawn
     }
+
+    void onChunkRemove() {
+        this.playersInMobSpawnRange = null;
+        this.playersInChunkTickRange = null;
+    }
     // Paper end - optimise anyPlayerCloseEnoughForSpawning
     long lastAutoSaveTime; // Paper - incremental autosave
     long inactiveTimeStart; // Paper - incremental autosave
@@ -133,7 +138,7 @@ public class ChunkHolder {
         this.setTicketLevel(level);
         this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
         this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
-        this.updateRanges(); // Paper - optimise anyPlayerCloseEnoughForSpawning
+        this.onChunkAdd(); // Paper - optimise anyPlayerCloseEnoughForSpawning
     }
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 0754c45fadf17d3ee2e30e161e77119aeefad9ba..243d0607fd5bdb0cc52fd5c1ba68834be17785f7 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -794,7 +794,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         } else {
             if (holder != null) {
                 holder.setTicketLevel(level);
-                holder.updateRanges(); // Paper - optimise anyPlayerCloseEnoughForSpawning
             }
 
             if (holder != null) {
@@ -809,6 +808,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 holder = (ChunkHolder) this.pendingUnloads.remove(pos);
                 if (holder != null) {
                     holder.setTicketLevel(level);
+                    holder.onChunkAdd(); // Paper - optimise anyPlayerCloseEnoughForSpawning - PUT HERE AFTER RE-ADDING ONLY
                 } else {
                     holder = new ChunkHolder(new ChunkPos(pos), level, this.level, this.lightEngine, this.queueSorter, this);
                     // Paper start
@@ -978,6 +978,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ChunkHolder playerchunk = this.updatingChunks.queueRemove(j); // Paper - Don't copy
 
             if (playerchunk != null) {
+                playerchunk.onChunkRemove(); // Paper
                 this.pendingUnloads.put(j, playerchunk);
                 this.modified = true;
                 this.scheduleUnload(j, playerchunk); // Paper - Move up - don't leak chunks
